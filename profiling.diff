diff --git a/src/java/voldemort/server/niosocket/AsyncRequestHandler.java b/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
index d4df125..85caa38 100644
--- a/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
+++ b/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
@@ -282,8 +282,16 @@ public class AsyncRequestHandler extends SelectorManagerWorker {
             if(logger.isTraceEnabled())
                 traceInputBufferState("Before streaming request handler");
 
+            // this is the lowest level in the NioSocketServer stack at which we
+            // still have a reference to the client IP address and port
+            long startNs = System.nanoTime();
+
             state = streamRequestHandler.handleRequest(dataInputStream, dataOutputStream);
 
+            logger.debug("Handled request from " + socketChannel.socket().getRemoteSocketAddress()
+                         + " at time: " + System.currentTimeMillis() + " elapsed time: "
+                         + (System.nanoTime() - startNs) + " ns");
+
             if(logger.isTraceEnabled())
                 traceInputBufferState("After streaming request handler");
         } catch(Exception e) {
diff --git a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
index b74b60a..b177ac7 100644
--- a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
+++ b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
@@ -101,6 +101,9 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
     private void handleGetVersion(DataInputStream inputStream,
                                   DataOutputStream outputStream,
                                   Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeNs = System.nanoTime();
+        long startTimeMs = System.currentTimeMillis();
+
         ByteArray key = readKey(inputStream);
         List<Version> results = null;
         try {
@@ -112,11 +115,22 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
             return;
         }
         outputStream.writeInt(results.size());
+
+        String clockStr = "";
+
         for(Version v: results) {
             byte[] clock = ((VectorClock) v).toBytes();
+
+            if(logger.isDebugEnabled())
+                clockStr += clock + " ";
+
             outputStream.writeInt(clock.length);
             outputStream.write(clock);
         }
+
+        logger.debug("GETVERSIONS started at: " + startTimeMs + " key: " + key + " "
+                     + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                     + "clocks: " + clockStr);
     }
 
     /**
@@ -269,6 +283,9 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
     private void handleGet(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = System.currentTimeMillis();
+        long startTimeNs = System.nanoTime();
+
         ByteArray key = readKey(inputStream);
 
         byte[] transforms = null;
@@ -286,11 +303,16 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
             return;
         }
         writeResults(outputStream, results);
+
+        debugLogReturnValue(key, results, startTimeMs, startTimeNs, "GET");
     }
 
     private void handleGetAll(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = System.currentTimeMillis();
+        long startTimeNs = System.nanoTime();
+
         // read keys
         int numKeys = inputStream.readInt();
         List<ByteArray> keys = new ArrayList<ByteArray>(numKeys);
@@ -321,18 +343,61 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
 
         // write back the results
         outputStream.writeInt(results.size());
+
+        logger.debug("GETALL start");
+
         for(Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
             // write the key
             outputStream.writeInt(entry.getKey().length());
             outputStream.write(entry.getKey().get());
             // write the values
             writeResults(outputStream, entry.getValue());
+
+            debugLogReturnValue(entry.getKey(),
+                                entry.getValue(),
+                                startTimeMs,
+                                startTimeNs,
+                                "GETALL");
+        }
+
+        logger.debug("GETALL end");
+    }
+
+    private void debugLogReturnValue(ByteArray key,
+                                     List<Versioned<byte[]>> values,
+                                     long startTimeMs,
+                                     long startTimeNs,
+                                     String getType) {
+        if(logger.isDebugEnabled()) {
+            long totalValueSize = 0;
+            String valueSizeStr = "[";
+            String valueHashStr = "[";
+            String versionsStr = "[";
+            for(Versioned<byte[]> b: values) {
+                int len = b.getValue().length;
+                totalValueSize += len;
+                valueSizeStr += len + ",";
+                valueHashStr += b.hashCode() + ",";
+                versionsStr += b.getVersion();
+            }
+            valueSizeStr += "]";
+            valueHashStr += "]";
+            versionsStr += "]";
+
+            logger.debug(getType + "start time: " + startTimeMs + " key: " + key + " "
+                         + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                         + " numResults: " + values.size() + " totalResultSize: " + totalValueSize
+                         + " resultSizes: " + valueSizeStr + " resultHashes: " + valueHashStr
+                         + " versions: " + versionsStr + " time: " + System.currentTimeMillis());
         }
     }
 
     private void handlePut(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = System.currentTimeMillis();
+        long startTimeNs = System.nanoTime();
+
         ByteArray key = readKey(inputStream);
         int valueSize = inputStream.readInt();
         byte[] bytes = new byte[valueSize];
@@ -352,11 +417,18 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        logger.debug("PUT started at: " + startTimeMs + " key: " + key + " "
+                     + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                     + "valueHash: " + value.hashCode() + " valueSize: " + valueSize
+                     + " clockSize: " + clock.sizeInBytes() + " time: "
+                     + System.currentTimeMillis());
     }
 
     private void handleDelete(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeNs = System.nanoTime();
         ByteArray key = readKey(inputStream);
         int versionSize = inputStream.readShort();
         byte[] versionBytes = new byte[versionSize];
@@ -369,6 +441,9 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        logger.debug("DELETE key: " + key + " " + (System.nanoTime() - startTimeNs)
+                     + " ns, keySize: " + key.length() + " clockSize: " + version.sizeInBytes());
     }
 
     private void writeException(DataOutputStream stream, VoldemortException e) throws IOException {
diff --git a/src/java/voldemort/store/bdb/BdbStorageEngine.java b/src/java/voldemort/store/bdb/BdbStorageEngine.java
index 61d809e..b6aaa46 100644
--- a/src/java/voldemort/store/bdb/BdbStorageEngine.java
+++ b/src/java/voldemort/store/bdb/BdbStorageEngine.java
@@ -250,12 +250,22 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
     public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys,
                                                           Map<ByteArray, byte[]> transforms)
             throws VoldemortException {
+
+        long startNs = System.nanoTime();
+
         StoreUtils.assertValidKeys(keys);
         Map<ByteArray, List<Versioned<byte[]>>> result = StoreUtils.newEmptyHashMap(keys);
         Cursor cursor = null;
+
+        String keyStr = "";
+
         try {
             cursor = getBdbDatabase().openCursor(null, null);
             for(ByteArray key: keys) {
+
+                if(logger.isDebugEnabled())
+                    keyStr += key + " ";
+
                 List<Versioned<byte[]>> values = get(cursor, key, readLockMode, versionedSerializer);
                 if(!values.isEmpty())
                     result.put(key, values);
@@ -266,6 +276,10 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
         } finally {
             attemptClose(cursor);
         }
+
+        logger.debug("Completed GETALL from keys " + keyStr + " in "
+                     + (System.nanoTime() - startNs) + " ns at " + System.currentTimeMillis());
+
         return result;
     }
 
@@ -275,6 +289,8 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                                    Serializer<T> serializer) throws DatabaseException {
         StoreUtils.assertValidKey(key);
 
+        long startNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         DatabaseEntry valueEntry = new DatabaseEntry();
         List<T> results = Lists.newArrayList();
@@ -284,6 +300,10 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                                                                                                                                                         lockMode)) {
             results.add(serializer.toObject(valueEntry.getData()));
         }
+
+        logger.debug("Completed GET from key " + key + " in " + (System.nanoTime() - startNs)
+                     + " ns at " + System.currentTimeMillis());
+
         return results;
     }
 
@@ -291,6 +311,8 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
 
+        long startNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         boolean succeeded = false;
         Transaction transaction = null;
@@ -338,10 +360,16 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             else
                 attemptAbort(transaction);
         }
+
+        logger.debug("Completed PUT to key " + key + " value " + value + " in "
+                     + (System.nanoTime() - startNs) + " ns at " + System.currentTimeMillis());
     }
 
     public boolean delete(ByteArray key, Version version) throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
+
+        long startNs = System.nanoTime();
+
         boolean deletedSomething = false;
         Cursor cursor = null;
         Transaction transaction = null;
@@ -366,6 +394,9 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             logger.error(e);
             throw new PersistenceFailureException(e);
         } finally {
+            logger.debug("Completed DELETE of key " + key + " in " + (System.nanoTime() - startNs)
+                         + " ns at " + System.currentTimeMillis());
+
             try {
                 attemptClose(cursor);
             } finally {
diff --git a/src/java/voldemort/store/routed/PipelineRoutedStore.java b/src/java/voldemort/store/routed/PipelineRoutedStore.java
index 38ff905..4a10bc7 100644
--- a/src/java/voldemort/store/routed/PipelineRoutedStore.java
+++ b/src/java/voldemort/store/routed/PipelineRoutedStore.java
@@ -144,6 +144,9 @@ public class PipelineRoutedStore extends RoutedStore {
     public List<Versioned<byte[]>> get(final ByteArray key, final byte[] transforms) {
         StoreUtils.assertValidKey(key);
 
+        long startMs = System.currentTimeMillis();
+        long startNs = System.nanoTime();
+
         BasicPipelineData<List<Versioned<byte[]>>> pipelineData = new BasicPipelineData<List<Versioned<byte[]>>>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountReads());
@@ -242,14 +245,35 @@ public class PipelineRoutedStore extends RoutedStore {
                 results.addAll(value);
         }
 
+        logger.debug("Finished GET for key " + key + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs) + " values: "
+                     + formatNodeValuesFromGet(pipelineData.getResponses()));
+
         return results;
     }
 
+    private <R> String formatNodeValuesFromGet(List<Response<ByteArray, List<Versioned<byte[]>>>> results) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<ByteArray, List<Versioned<byte[]>>> r: results) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys,
                                                           Map<ByteArray, byte[]> transforms)
             throws VoldemortException {
         StoreUtils.assertValidKeys(keys);
 
+        long startNs = System.nanoTime();
+        long startMs = System.currentTimeMillis();
+
         boolean allowReadRepair = repairReads && (transforms == null || transforms.size() == 0);
 
         GetAllPipelineData pipelineData = new GetAllPipelineData();
@@ -318,12 +342,33 @@ public class PipelineRoutedStore extends RoutedStore {
         if(pipelineData.getFatalError() != null)
             throw pipelineData.getFatalError();
 
+        logger.debug("Finished GETALL for keys " + keys + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs) + " values: "
+                     + formatNodeValuesFromGetAll(pipelineData.getResponses()));
+
         return pipelineData.getResult();
     }
 
+    private <R> String formatNodeValuesFromGetAll(List<Response<Iterable<ByteArray>, Map<ByteArray, List<Versioned<byte[]>>>>> list) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<Iterable<ByteArray>, Map<ByteArray, List<Versioned<byte[]>>>> r: list) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public List<Version> getVersions(final ByteArray key) {
         StoreUtils.assertValidKey(key);
 
+        long startMs = System.currentTimeMillis();
+        long startNs = System.nanoTime();
+
         BasicPipelineData<List<Version>> pipelineData = new BasicPipelineData<List<Version>>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountReads());
@@ -403,12 +448,33 @@ public class PipelineRoutedStore extends RoutedStore {
         for(Response<ByteArray, List<Version>> response: pipelineData.getResponses())
             results.addAll(response.getValue());
 
+        logger.debug("Finished GETVERSIONS for key " + key + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs) + " values: "
+                     + formatNodeValuesFromGetVersions(pipelineData.getResponses()));
+
         return results;
     }
 
+    private <R> String formatNodeValuesFromGetVersions(List<Response<ByteArray, List<Version>>> results) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<ByteArray, List<Version>> r: results) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public boolean delete(final ByteArray key, final Version version) throws VoldemortException {
         StoreUtils.assertValidKey(key);
 
+        long startMs = System.currentTimeMillis();
+        long startNs = System.nanoTime();
+
         BasicPipelineData<Boolean> pipelineData = new BasicPipelineData<Boolean>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountWrites());
@@ -480,6 +546,9 @@ public class PipelineRoutedStore extends RoutedStore {
             throw e;
         }
 
+        logger.debug("Finished DELETE for key " + key.get() + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs));
+
         if(pipelineData.getFatalError() != null)
             throw pipelineData.getFatalError();
 
diff --git a/src/java/voldemort/store/routed/action/AbstractReadRepair.java b/src/java/voldemort/store/routed/action/AbstractReadRepair.java
index 2588c36..c87f397 100644
--- a/src/java/voldemort/store/routed/action/AbstractReadRepair.java
+++ b/src/java/voldemort/store/routed/action/AbstractReadRepair.java
@@ -24,9 +24,9 @@ import voldemort.cluster.Node;
 import voldemort.store.nonblockingstore.NonblockingStore;
 import voldemort.store.routed.NodeValue;
 import voldemort.store.routed.Pipeline;
+import voldemort.store.routed.Pipeline.Event;
 import voldemort.store.routed.PipelineData;
 import voldemort.store.routed.ReadRepairer;
-import voldemort.store.routed.Pipeline.Event;
 import voldemort.utils.ByteArray;
 import voldemort.versioning.VectorClock;
 import voldemort.versioning.Versioned;
@@ -75,6 +75,8 @@ public abstract class AbstractReadRepair<K, V, PD extends PipelineData<K, V>> ex
     public void execute(Pipeline pipeline) {
         insertNodeValues();
 
+        long startNs = System.nanoTime();
+
         if(nodeValues.size() > 1 && preferred > 1) {
             List<NodeValue<ByteArray, byte[]>> toReadRepair = Lists.newArrayList();
 
@@ -111,6 +113,15 @@ public abstract class AbstractReadRepair<K, V, PD extends PipelineData<K, V>> ex
                     logger.debug("Read repair failed: ", e);
                 }
             }
+
+            if(logger.isDebugEnabled()) {
+                String logStr = "Repaired (node, key, version): (";
+                for(NodeValue<ByteArray, byte[]> v: toReadRepair) {
+                    logStr += "(" + v.getNodeId() + ", " + v.getKey() + "," + v.getVersion() + ") ";
+                }
+                logStr += "in " + (System.nanoTime() - startNs) + " ns";
+                logger.debug(logStr);
+            }
         }
 
         pipeline.addEvent(completeEvent);
diff --git a/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java b/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
index c459057..ddede94 100644
--- a/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
@@ -129,6 +129,9 @@ public class PerformParallelPutRequests extends
                                                                                            requestTime);
                     responses.put(node.getId(), response);
 
+                    logger.debug("Finished secondary PUT for key " + key + "; took " + requestTime
+                                 + " ms on node " + node.getId() + "(" + node.getHost() + ")");
+
                     if(isHintedHandoffEnabled() && pipeline.isFinished()) {
                         if(response.getValue() instanceof UnreachableStoreException) {
                             Slop slop = new Slop(pipelineData.getStoreName(),
diff --git a/src/java/voldemort/store/routed/action/PerformParallelRequests.java b/src/java/voldemort/store/routed/action/PerformParallelRequests.java
index a5a0ef9..d4fa4a3 100644
--- a/src/java/voldemort/store/routed/action/PerformParallelRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformParallelRequests.java
@@ -95,6 +95,8 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             final Node node = nodes.get(i);
             pipelineData.incrementNodeIndex();
 
+            final long startMs = System.currentTimeMillis();
+
             NonblockingStoreCallback callback = new NonblockingStoreCallback() {
 
                 public void requestComplete(Object result, long requestTime) {
@@ -107,6 +109,11 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
                                                                                            key,
                                                                                            result,
                                                                                            requestTime);
+
+                    logger.debug("Finished GET for key " + key + "; started at " + startMs
+                                 + " took " + requestTime + " ms on node " + node.getId() + "("
+                                 + node.getHost() + ")");
+
                     responses.put(node.getId(), response);
                     latch.countDown();
 
@@ -164,6 +171,9 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
         }
 
+        logger.debug("GET for key " + key + " successes: " + pipelineData.getSuccesses()
+                     + " preferred: " + preferred + " required: " + required);
+
         if(pipelineData.getSuccesses() < required) {
             if(insufficientSuccessesEvent != null) {
                 pipeline.addEvent(insufficientSuccessesEvent);
@@ -184,7 +194,6 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
 
         } else {
-
             if(pipelineData.getZonesRequired() != null) {
 
                 int zonesSatisfied = pipelineData.getZoneResponses().size();
@@ -216,5 +225,4 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
         }
     }
-
 }
diff --git a/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java b/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
index 2f5d07e..9b5f25b 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
@@ -79,6 +79,9 @@ public class PerformSerialGetAllRequests
             boolean zoneRequirement = false;
             MutableInt successCount = pipelineData.getSuccessCount(key);
 
+            logger.debug("GETALL for key " + key + " successes: " + successCount.intValue()
+                         + " preferred: " + preferred + " required: " + required);
+
             if(successCount.intValue() >= preferred) {
                 if(pipelineData.getZonesRequired() != null) {
 
@@ -132,6 +135,10 @@ public class PerformSerialGetAllRequests
                     pipelineData.getResponses().add(response);
                     failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
 
+                    logger.debug("GET for key " + key + " successes: " + successCount.intValue()
+                                 + " preferred: " + preferred + " required: " + required
+                                 + " new GET success on node " + node.getId());
+
                     HashSet<Integer> zoneResponses = null;
                     if(pipelineData.getKeyToZoneResponse().containsKey(key)) {
                         zoneResponses = pipelineData.getKeyToZoneResponse().get(key);
@@ -187,5 +194,4 @@ public class PerformSerialGetAllRequests
 
         pipeline.addEvent(completeEvent);
     }
-
 }
\ No newline at end of file
diff --git a/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java b/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
index 5d8debe..b6ed22b 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
@@ -74,11 +74,15 @@ public class PerformSerialPutRequests extends
         int currentNode = 0;
         List<Node> nodes = pipelineData.getNodes();
 
+        long startMasterMs = System.currentTimeMillis();
+        long startMasterNs = System.nanoTime();
+
         if(logger.isDebugEnabled())
             logger.debug("Performing serial put requests to determine master");
 
+        Node node = null;
         for(; currentNode < nodes.size(); currentNode++) {
-            Node node = nodes.get(currentNode);
+            node = nodes.get(currentNode);
             pipelineData.incrementNodeIndex();
 
             VectorClock versionedClock = (VectorClock) versioned.getVersion();
@@ -108,6 +112,10 @@ public class PerformSerialPutRequests extends
             } catch(Exception e) {
                 long requestTime = (System.nanoTime() - start) / Time.NS_PER_MS;
 
+                logger.debug("Master PUT at node " + currentNode + "(" + node.getHost() + ")"
+                             + " failed (" + e.getMessage() + ") in " + (System.nanoTime() - start)
+                             + " ns");
+
                 if(handleResponseError(e, node, requestTime, pipeline, failureDetector))
                     return;
             }
@@ -161,6 +169,10 @@ public class PerformSerialPutRequests extends
                 }
             }
         } else {
+            logger.debug("Finished master PUT for key " + key + "; started at " + startMasterMs
+                         + " took " + (System.nanoTime() - startMasterNs) + " ns on node "
+                         + node.getId() + "(" + node.getHost() + ")");
+
             pipeline.addEvent(masterDeterminedEvent);
         }
     }
diff --git a/src/java/voldemort/store/routed/action/PerformSerialRequests.java b/src/java/voldemort/store/routed/action/PerformSerialRequests.java
index 70c8fa5..356a620 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialRequests.java
@@ -98,6 +98,10 @@ public class PerformSerialRequests<V, PD extends BasicPipelineData<V>> extends
                                                                              result,
                                                                              ((System.nanoTime() - start) / Time.NS_PER_MS));
 
+                logger.debug("GET for key " + key + " successes: " + pipelineData.getSuccesses()
+                             + " preferred: " + preferred + " required: " + required
+                             + " new GET success on node " + node.getId());
+
                 pipelineData.incrementSuccesses();
                 pipelineData.getResponses().add(response);
                 failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
diff --git a/src/java/voldemort/store/slop/HintedHandoff.java b/src/java/voldemort/store/slop/HintedHandoff.java
index a4a6621..bc15ef7 100644
--- a/src/java/voldemort/store/slop/HintedHandoff.java
+++ b/src/java/voldemort/store/slop/HintedHandoff.java
@@ -27,10 +27,10 @@ import voldemort.serialization.Serializer;
 import voldemort.serialization.SlopSerializer;
 import voldemort.store.Store;
 import voldemort.store.UnreachableStoreException;
-import voldemort.store.slop.strategy.HintedHandoffStrategy;
 import voldemort.store.nonblockingstore.NonblockingStore;
 import voldemort.store.nonblockingstore.NonblockingStoreCallback;
 import voldemort.store.routed.Response;
+import voldemort.store.slop.strategy.HintedHandoffStrategy;
 import voldemort.utils.ByteArray;
 import voldemort.utils.Time;
 import voldemort.utils.Utils;
@@ -67,7 +67,8 @@ public class HintedHandoff {
      * Create a Hinted Handoff object
      * 
      * @param failureDetector The failure detector
-     * @param nonblockingSlopStores A map of node ids to nonb-locking slop stores
+     * @param nonblockingSlopStores A map of node ids to nonb-locking slop
+     *        stores
      * @param slopStores A map of node ids to blocking slop stores
      * @param handoffStrategy The {@link HintedHandoffStrategy} implementation
      * @param failedNodes A list of nodes in the original preflist for the
@@ -89,30 +90,33 @@ public class HintedHandoff {
     }
 
     /**
-     * Like {@link #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)},
-     * but doesn't block the pipeline. Intended for handling prolonged failures without
-     * incurring a performance cost.
-     *
-     * @see #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)
+     * Like
+     * {@link #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)}
+     * , but doesn't block the pipeline. Intended for handling prolonged
+     * failures without incurring a performance cost.
+     * 
+     * @see #sendHintSerial(voldemort.cluster.Node,
+     *      voldemort.versioning.Version, Slop)
      */
     public void sendHintParallel(final Node failedNode, final Version version, final Slop slop) {
         final ByteArray slopKey = slop.makeKey();
-        Versioned<byte[]> slopVersioned = new Versioned<byte[]>(slopSerializer.toBytes(slop), version);
+        Versioned<byte[]> slopVersioned = new Versioned<byte[]>(slopSerializer.toBytes(slop),
+                                                                version);
 
         for(final Node node: handoffStrategy.routeHint(failedNode)) {
             int nodeId = node.getId();
-            if(logger.isTraceEnabled())
-                logger.trace("Sending an async hint to " + nodeId);
+
+            logger.debug("Sending an async hint to " + nodeId);
 
             if(!failedNodes.contains(node) && failureDetector.isAvailable(node)) {
                 NonblockingStore nonblockingStore = nonblockingSlopStores.get(nodeId);
                 Utils.notNull(nonblockingStore);
                 final long startNs = System.nanoTime();
-                if(logger.isTraceEnabled())
-                    logger.trace("Attempt to write " + slop.getKey() + " for " + failedNode
-                                 + " to node " + node);
+                logger.debug("Slop attempt to write " + slop.getKey() + " for " + failedNode
+                             + " to node " + node);
 
                 NonblockingStoreCallback callback = new NonblockingStoreCallback() {
+
                     public void requestComplete(Object result, long requestTime) {
                         Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                                slopKey,
@@ -127,31 +131,38 @@ public class HintedHandoff {
                                     failedNodes.add(node);
                                 if(response.getValue() instanceof UnreachableStoreException) {
                                     UnreachableStoreException use = (UnreachableStoreException) response.getValue();
+
+                                    logger.debug("Write of key " + slop.getKey() + " for "
+                                                 + failedNode + " to node " + node
+                                                 + " failed due to unreachable: "
+                                                 + use.getMessage());
+
                                     failureDetector.recordException(node,
                                                                     (System.nanoTime() - startNs)
-                                                                    / Time.NS_PER_MS,
+                                                                            / Time.NS_PER_MS,
                                                                     use);
                                 }
                                 sendHintSerial(failedNode, version, slop);
                             }
                             return;
                         }
+
+                        logger.debug("Slop write of key " + slop.getKey() + " for " + failedNode
+                                     + " to node " + node + " succeded in "
+                                     + (System.nanoTime() - startNs) + " ns");
+
                         failureDetector.recordSuccess(node, (System.nanoTime() - startNs)
                                                             / Time.NS_PER_MS);
 
                     }
                 };
 
-                nonblockingStore.submitPutRequest(slopKey,
-                                                  slopVersioned,
-                                                  null,
-                                                  callback,
-                                                  timeoutMs);
+                nonblockingStore.submitPutRequest(slopKey, slopVersioned, null, callback, timeoutMs);
                 break;
             }
         }
     }
-    
+
     /**
      * Send a hint of a request originally meant for the failed node to another
      * node in the ring, as selected by the {@link HintedHandoffStrategy}
@@ -166,8 +177,7 @@ public class HintedHandoff {
         boolean persisted = false;
         for(Node node: handoffStrategy.routeHint(failedNode)) {
             int nodeId = node.getId();
-            if(logger.isTraceEnabled())
-                logger.trace("Trying to send hint to " + nodeId);
+            logger.trace("Trying to send hint to " + nodeId);
 
             if(!failedNodes.contains(node) && failureDetector.isAvailable(node)) {
                 Store<ByteArray, Slop, byte[]> slopStore = slopStores.get(nodeId);
@@ -175,10 +185,8 @@ public class HintedHandoff {
                 long startNs = System.nanoTime();
 
                 try {
-                    if(logger.isTraceEnabled())
-                        logger.trace("Attempt to handoff " + slop.getOperation() + " on "
-                                     + slop.getKey() + " for " + failedNode
-                                     + " to node " + node);
+                    logger.debug("Slop attempt to write " + slop.getKey() + " for " + failedNode
+                                 + " to node " + node);
 
                     // No transform needs to applied to the slop
                     slopStore.put(slop.makeKey(), new Versioned<Slop>(slop, version), null);
@@ -197,6 +205,10 @@ public class HintedHandoff {
                 } catch(ObsoleteVersionException e) {
                     logger.debug(e, e);
                 }
+
+                logger.debug("Slop write of key " + slop.getKey() + " for " + failedNode
+                             + " to node " + node + " succeded in " + (System.nanoTime() - startNs)
+                             + " ns");
             }
         }
 
diff --git a/src/java/voldemort/store/socket/SocketStore.java b/src/java/voldemort/store/socket/SocketStore.java
index 0886341..d83ac44 100644
--- a/src/java/voldemort/store/socket/SocketStore.java
+++ b/src/java/voldemort/store/socket/SocketStore.java
@@ -25,6 +25,7 @@ import java.util.Map;
 
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
+import org.mortbay.log.Log;
 
 import voldemort.VoldemortException;
 import voldemort.client.protocol.RequestFormat;
@@ -240,17 +241,35 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
     private <T> T request(ClientRequest<T> delegate, String operationName) {
         ClientRequestExecutor clientRequestExecutor = pool.checkout(destination);
+
+        long startTimeNs = System.nanoTime();
+        long startTimeMs = System.currentTimeMillis();
+
+        String debugMsgStr = "";
+
         BlockingClientRequest<T> blockingClientRequest = null;
         try {
             blockingClientRequest = new BlockingClientRequest<T>(delegate, timeoutMs);
             clientRequestExecutor.addClientRequest(blockingClientRequest, timeoutMs);
             blockingClientRequest.await();
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "success";
+
             return blockingClientRequest.getResult();
         } catch(InterruptedException e) {
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "unreachable: " + e.getMessage();
+
             throw new UnreachableStoreException("Failure in " + operationName + " on "
                                                 + destination + ": " + e.getMessage(), e);
         } catch(IOException e) {
             clientRequestExecutor.close();
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "failure: " + e.getMessage();
+
             throw new UnreachableStoreException("Failure in " + operationName + " on "
                                                 + destination + ": " + e.getMessage(), e);
         } finally {
@@ -258,6 +277,16 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                 // close the executor if we timed out
                 clientRequestExecutor.close();
             }
+
+            Log.debug("Sync request end, type: " + operationName + " totalTimeNs: "
+                      + (startTimeNs - System.nanoTime()) + " start time: " + startTimeMs
+                      + "end time: " + System.currentTimeMillis() + "client:"
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalAddress() + ":"
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalPort()
+                      + " server: "
+                      + clientRequestExecutor.getSocketChannel().socket().getRemoteSocketAddress()
+                      + " outcome: " + debugMsgStr);
+
             pool.checkin(destination, clientRequestExecutor);
         }
     }
@@ -285,6 +314,14 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
         try {
             clientRequestExecutor = pool.checkout(destination);
+
+            Log.debug("Async request start; type: " + operationName + " time: "
+                      + System.currentTimeMillis() + " server: "
+                      + clientRequestExecutor.getSocketChannel().socket().getRemoteSocketAddress()
+                      + " local socket: "
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalAddress() + ":"
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalPort());
+
         } catch(Exception e) {
             // If we can't check out a socket from the pool, we'll usually get
             // either an IOException (subclass) or an UnreachableStoreException
@@ -335,6 +372,17 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
         private void invokeCallback(Object o, long requestTime) {
             if(callback != null) {
                 try {
+                    Log.warn("Async request end; time: "
+                             + System.currentTimeMillis()
+                             + " server: "
+                             + clientRequestExecutor.getSocketChannel()
+                                                    .socket()
+                                                    .getRemoteSocketAddress() + " local socket: "
+                             + clientRequestExecutor.getSocketChannel().socket().getLocalAddress()
+                             + ":"
+                             + clientRequestExecutor.getSocketChannel().socket().getLocalPort()
+                             + " result: " + o.toString());
+
                     callback.requestComplete(o, requestTime);
                 } catch(Exception e) {
                     if(logger.isEnabledFor(Level.WARN))
