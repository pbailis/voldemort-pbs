diff --git a/src/java/voldemort/server/niosocket/AsyncRequestHandler.java b/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
index d4df125..261e21d 100644
--- a/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
+++ b/src/java/voldemort/server/niosocket/AsyncRequestHandler.java
@@ -282,8 +282,23 @@ public class AsyncRequestHandler extends SelectorManagerWorker {
             if(logger.isTraceEnabled())
                 traceInputBufferState("Before streaming request handler");
 
+            // this is the lowest level in the NioSocketServer stack at which we
+            // still have a reference to the client IP address and port
+            long startNs = -1;
+
+            if(logger.isDebugEnabled())
+                startNs = System.nanoTime();
+
             state = streamRequestHandler.handleRequest(dataInputStream, dataOutputStream);
 
+            if(logger.isDebugEnabled()) {
+                logger.debug("Handled request from "
+                             + socketChannel.socket().getRemoteSocketAddress() + " handlerRef: "
+                             + System.identityHashCode(streamRequestHandler) + " at time: "
+                             + System.currentTimeMillis() + " elapsed time: "
+                             + (System.nanoTime() - startNs) + " ns");
+            }
+
             if(logger.isTraceEnabled())
                 traceInputBufferState("After streaming request handler");
         } catch(Exception e) {
diff --git a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
index b74b60a..e905bf3 100644
--- a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
+++ b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
@@ -101,6 +101,14 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
     private void handleGetVersion(DataInputStream inputStream,
                                   DataOutputStream outputStream,
                                   Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         ByteArray key = readKey(inputStream);
         List<Version> results = null;
         try {
@@ -112,11 +120,25 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
             return;
         }
         outputStream.writeInt(results.size());
+
+        String clockStr = "";
+
         for(Version v: results) {
             byte[] clock = ((VectorClock) v).toBytes();
+
+            if(logger.isDebugEnabled())
+                clockStr += clock + " ";
+
             outputStream.writeInt(clock.length);
             outputStream.write(clock);
         }
+
+        if(logger.isDebugEnabled()) {
+            logger.debug("GETVERSIONS started at: " + startTimeMs + " handlerRef: "
+                         + System.identityHashCode(this) + " key: " + key + " "
+                         + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                         + "clocks: " + clockStr);
+        }
     }
 
     /**
@@ -269,6 +291,14 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
     private void handleGet(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         ByteArray key = readKey(inputStream);
 
         byte[] transforms = null;
@@ -286,11 +316,22 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
             return;
         }
         writeResults(outputStream, results);
+        if(logger.isDebugEnabled()) {
+            debugLogReturnValue(key, results, startTimeMs, startTimeNs, "GET");
+        }
     }
 
     private void handleGetAll(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         // read keys
         int numKeys = inputStream.readInt();
         List<ByteArray> keys = new ArrayList<ByteArray>(numKeys);
@@ -321,18 +362,67 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
 
         // write back the results
         outputStream.writeInt(results.size());
+
+        logger.debug("GETALL start");
+
         for(Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
             // write the key
             outputStream.writeInt(entry.getKey().length());
             outputStream.write(entry.getKey().get());
             // write the values
             writeResults(outputStream, entry.getValue());
+
+            if(logger.isDebugEnabled()) {
+                debugLogReturnValue(entry.getKey(),
+                                    entry.getValue(),
+                                    startTimeMs,
+                                    startTimeNs,
+                                    "GETALL");
+            }
         }
+
+        logger.debug("GETALL end");
+    }
+
+    private void debugLogReturnValue(ByteArray key,
+                                     List<Versioned<byte[]>> values,
+                                     long startTimeMs,
+                                     long startTimeNs,
+                                     String getType) {
+        long totalValueSize = 0;
+        String valueSizeStr = "[";
+        String valueHashStr = "[";
+        String versionsStr = "[";
+        for(Versioned<byte[]> b: values) {
+            int len = b.getValue().length;
+            totalValueSize += len;
+            valueSizeStr += len + ",";
+            valueHashStr += b.hashCode() + ",";
+            versionsStr += b.getVersion();
+        }
+        valueSizeStr += "]";
+        valueHashStr += "]";
+        versionsStr += "]";
+
+        logger.debug(getType + " handlerRef: " + System.identityHashCode(this) + " start time: "
+                     + startTimeMs + " key: " + key + " elapsed time: "
+                     + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                     + " numResults: " + values.size() + " totalResultSize: " + totalValueSize
+                     + " resultSizes: " + valueSizeStr + " resultHashes: " + valueHashStr
+                     + " versions: " + versionsStr + " current time: " + System.currentTimeMillis());
     }
 
     private void handlePut(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         ByteArray key = readKey(inputStream);
         int valueSize = inputStream.readInt();
         byte[] bytes = new byte[valueSize];
@@ -352,11 +442,28 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        if(logger.isDebugEnabled()) {
+            logger.debug("PUT started at: " + startTimeMs + " handlerRef: "
+                         + System.identityHashCode(this) + " key: " + key + " "
+                         + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                         + "valueHash: " + value.hashCode() + " valueSize: " + valueSize
+                         + " clockSize: " + clock.sizeInBytes() + " time: "
+                         + System.currentTimeMillis());
+        }
     }
 
     private void handleDelete(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         ByteArray key = readKey(inputStream);
         int versionSize = inputStream.readShort();
         byte[] versionBytes = new byte[versionSize];
@@ -369,6 +476,13 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        if(logger.isDebugEnabled()) {
+            logger.debug("DELETE started at: " + startTimeMs + " key: " + key + " handlerRef: "
+                         + System.identityHashCode(this) + " time: "
+                         + (System.nanoTime() - startTimeNs) + " ns, keySize: " + key.length()
+                         + " clockSize: " + version.sizeInBytes());
+        }
     }
 
     private void writeException(DataOutputStream stream, VoldemortException e) throws IOException {
diff --git a/src/java/voldemort/store/bdb/BdbStorageEngine.java b/src/java/voldemort/store/bdb/BdbStorageEngine.java
index 61d809e..663824c 100644
--- a/src/java/voldemort/store/bdb/BdbStorageEngine.java
+++ b/src/java/voldemort/store/bdb/BdbStorageEngine.java
@@ -209,6 +209,11 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                             Serializer<T> serializer) throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
 
+        long startTimeNs = -1;
+
+        if(logger.isTraceEnabled())
+            startTimeNs = System.nanoTime();
+
         Cursor cursor = null;
         try {
             cursor = getBdbDatabase().openCursor(null, null);
@@ -225,6 +230,13 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             logger.error(e);
             throw new PersistenceFailureException(e);
         } finally {
+            if(logger.isTraceEnabled()) {
+                logger.trace("Completed GET from key " + key + " (keyRef: "
+                             + System.identityHashCode(key) + ") in "
+                             + (System.nanoTime() - startTimeNs) + " ns at "
+                             + System.currentTimeMillis());
+            }
+
             attemptClose(cursor);
         }
     }
@@ -250,12 +262,22 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
     public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys,
                                                           Map<ByteArray, byte[]> transforms)
             throws VoldemortException {
+
+        long startTimeNs = System.nanoTime();
+
         StoreUtils.assertValidKeys(keys);
         Map<ByteArray, List<Versioned<byte[]>>> result = StoreUtils.newEmptyHashMap(keys);
         Cursor cursor = null;
+
+        String keyStr = "";
+
         try {
             cursor = getBdbDatabase().openCursor(null, null);
             for(ByteArray key: keys) {
+
+                if(logger.isDebugEnabled())
+                    keyStr += key + " ";
+
                 List<Versioned<byte[]>> values = get(cursor, key, readLockMode, versionedSerializer);
                 if(!values.isEmpty())
                     result.put(key, values);
@@ -266,6 +288,12 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
         } finally {
             attemptClose(cursor);
         }
+
+        if(logger.isTraceEnabled())
+            logger.trace("Completed GETALL from keys " + keyStr + " in "
+                         + (System.nanoTime() - startTimeNs) + " ns at "
+                         + System.currentTimeMillis());
+
         return result;
     }
 
@@ -275,6 +303,11 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                                    Serializer<T> serializer) throws DatabaseException {
         StoreUtils.assertValidKey(key);
 
+        long startTimeNs = -1;
+
+        if(logger.isTraceEnabled())
+            startTimeNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         DatabaseEntry valueEntry = new DatabaseEntry();
         List<T> results = Lists.newArrayList();
@@ -284,6 +317,13 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                                                                                                                                                         lockMode)) {
             results.add(serializer.toObject(valueEntry.getData()));
         }
+
+        if(logger.isTraceEnabled()) {
+            logger.trace("Completed GET from key " + key + " in "
+                         + (System.nanoTime() - startTimeNs) + " ns at "
+                         + System.currentTimeMillis());
+        }
+
         return results;
     }
 
@@ -291,6 +331,11 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
 
+        long startTimeNs = -1;
+
+        if(logger.isTraceEnabled())
+            startTimeNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         boolean succeeded = false;
         Transaction transaction = null;
@@ -338,10 +383,23 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             else
                 attemptAbort(transaction);
         }
+
+        if(logger.isTraceEnabled()) {
+            logger.trace("Completed PUT to key " + key + " (keyRef: "
+                         + System.identityHashCode(key) + " value " + value + " in "
+                         + (System.nanoTime() - startTimeNs) + " ns at "
+                         + System.currentTimeMillis());
+        }
     }
 
     public boolean delete(ByteArray key, Version version) throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
+
+        long startTimeNs = -1;
+
+        if(logger.isTraceEnabled())
+            startTimeNs = System.nanoTime();
+
         boolean deletedSomething = false;
         Cursor cursor = null;
         Transaction transaction = null;
@@ -366,6 +424,14 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             logger.error(e);
             throw new PersistenceFailureException(e);
         } finally {
+
+            if(logger.isTraceEnabled()) {
+                logger.trace("Completed DELETE of key " + key + " (keyRef: "
+                             + System.identityHashCode(key) + ") in "
+                             + (System.nanoTime() - startTimeNs) + " ns at "
+                             + System.currentTimeMillis());
+            }
+
             try {
                 attemptClose(cursor);
             } finally {
diff --git a/src/java/voldemort/store/routed/PipelineRoutedStore.java b/src/java/voldemort/store/routed/PipelineRoutedStore.java
index 38ff905..ef7de16 100644
--- a/src/java/voldemort/store/routed/PipelineRoutedStore.java
+++ b/src/java/voldemort/store/routed/PipelineRoutedStore.java
@@ -144,6 +144,14 @@ public class PipelineRoutedStore extends RoutedStore {
     public List<Versioned<byte[]>> get(final ByteArray key, final byte[] transforms) {
         StoreUtils.assertValidKey(key);
 
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         BasicPipelineData<List<Versioned<byte[]>>> pipelineData = new BasicPipelineData<List<Versioned<byte[]>>>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountReads());
@@ -242,14 +250,43 @@ public class PipelineRoutedStore extends RoutedStore {
                 results.addAll(value);
         }
 
+        if(logger.isDebugEnabled()) {
+            logger.debug("Finished GET for key " + key + " keyRef: " + System.identityHashCode(key)
+                         + "; started at " + startTimeMs + " took "
+                         + (System.nanoTime() - startTimeNs) + " values: "
+                         + formatNodeValuesFromGet(pipelineData.getResponses()));
+        }
+
         return results;
     }
 
+    private <R> String formatNodeValuesFromGet(List<Response<ByteArray, List<Versioned<byte[]>>>> results) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<ByteArray, List<Versioned<byte[]>>> r: results) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public Map<ByteArray, List<Versioned<byte[]>>> getAll(Iterable<ByteArray> keys,
                                                           Map<ByteArray, byte[]> transforms)
             throws VoldemortException {
         StoreUtils.assertValidKeys(keys);
 
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         boolean allowReadRepair = repairReads && (transforms == null || transforms.size() == 0);
 
         GetAllPipelineData pipelineData = new GetAllPipelineData();
@@ -318,12 +355,41 @@ public class PipelineRoutedStore extends RoutedStore {
         if(pipelineData.getFatalError() != null)
             throw pipelineData.getFatalError();
 
+        if(logger.isDebugEnabled()) {
+            logger.debug("Finished GETALL for keys " + keys + " keyRef: "
+                         + System.identityHashCode(keys) + "; started at " + startTimeMs + " took "
+                         + (System.nanoTime() - startTimeNs) + " values: "
+                         + formatNodeValuesFromGetAll(pipelineData.getResponses()));
+        }
+
         return pipelineData.getResult();
     }
 
+    private <R> String formatNodeValuesFromGetAll(List<Response<Iterable<ByteArray>, Map<ByteArray, List<Versioned<byte[]>>>>> list) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<Iterable<ByteArray>, Map<ByteArray, List<Versioned<byte[]>>>> r: list) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public List<Version> getVersions(final ByteArray key) {
         StoreUtils.assertValidKey(key);
 
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         BasicPipelineData<List<Version>> pipelineData = new BasicPipelineData<List<Version>>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountReads());
@@ -403,12 +469,41 @@ public class PipelineRoutedStore extends RoutedStore {
         for(Response<ByteArray, List<Version>> response: pipelineData.getResponses())
             results.addAll(response.getValue());
 
+        if(logger.isDebugEnabled()) {
+            logger.debug("Finished GETVERSIONS for key " + key + " keyRef: "
+                         + System.identityHashCode(key) + "; started at " + startTimeMs + " took "
+                         + (System.nanoTime() - startTimeNs) + " values: "
+                         + formatNodeValuesFromGetVersions(pipelineData.getResponses()));
+        }
+
         return results;
     }
 
+    private <R> String formatNodeValuesFromGetVersions(List<Response<ByteArray, List<Version>>> results) {
+        // log all retrieved values
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        for(Response<ByteArray, List<Version>> r: results) {
+            builder.append("(nodeId=" + r.getNode().getId() + ", key=" + r.getKey()
+                           + ", retrieved= " + r.getValue() + ")");
+            builder.append(", ");
+        }
+        builder.append("}");
+
+        return builder.toString();
+    }
+
     public boolean delete(final ByteArray key, final Version version) throws VoldemortException {
         StoreUtils.assertValidKey(key);
 
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         BasicPipelineData<Boolean> pipelineData = new BasicPipelineData<Boolean>();
         if(zoneRoutingEnabled)
             pipelineData.setZonesRequired(storeDef.getZoneCountWrites());
@@ -480,6 +575,12 @@ public class PipelineRoutedStore extends RoutedStore {
             throw e;
         }
 
+        if(logger.isDebugEnabled()) {
+            logger.debug("Finished DELETE for key " + key.get() + " keyRef: "
+                         + System.identityHashCode(key) + "; started at " + startTimeMs + " took "
+                         + (System.nanoTime() - startTimeNs));
+        }
+
         if(pipelineData.getFatalError() != null)
             throw pipelineData.getFatalError();
 
@@ -497,6 +598,15 @@ public class PipelineRoutedStore extends RoutedStore {
 
     public void put(ByteArray key, Versioned<byte[]> versioned, byte[] transforms)
             throws VoldemortException {
+
+        long startTimeMs = -1;
+        long startTimeNs = -1;
+
+        if(logger.isDebugEnabled()) {
+            startTimeMs = System.currentTimeMillis();
+            startTimeNs = System.nanoTime();
+        }
+
         StoreUtils.assertValidKey(key);
         PutPipelineData pipelineData = new PutPipelineData();
         if(zoneRoutingEnabled)
@@ -591,6 +701,12 @@ public class PipelineRoutedStore extends RoutedStore {
             throw e;
         }
 
+        if(logger.isDebugEnabled()) {
+            logger.debug("Finished GET for key " + key + " keyRef: " + System.identityHashCode(key)
+                         + "; started at " + startTimeMs + " took "
+                         + (System.nanoTime() - startTimeNs) + " value: " + versioned);
+        }
+
         if(pipelineData.getFatalError() != null)
             throw pipelineData.getFatalError();
     }
diff --git a/src/java/voldemort/store/routed/action/AbstractReadRepair.java b/src/java/voldemort/store/routed/action/AbstractReadRepair.java
index 2588c36..c87f397 100644
--- a/src/java/voldemort/store/routed/action/AbstractReadRepair.java
+++ b/src/java/voldemort/store/routed/action/AbstractReadRepair.java
@@ -24,9 +24,9 @@ import voldemort.cluster.Node;
 import voldemort.store.nonblockingstore.NonblockingStore;
 import voldemort.store.routed.NodeValue;
 import voldemort.store.routed.Pipeline;
+import voldemort.store.routed.Pipeline.Event;
 import voldemort.store.routed.PipelineData;
 import voldemort.store.routed.ReadRepairer;
-import voldemort.store.routed.Pipeline.Event;
 import voldemort.utils.ByteArray;
 import voldemort.versioning.VectorClock;
 import voldemort.versioning.Versioned;
@@ -75,6 +75,8 @@ public abstract class AbstractReadRepair<K, V, PD extends PipelineData<K, V>> ex
     public void execute(Pipeline pipeline) {
         insertNodeValues();
 
+        long startNs = System.nanoTime();
+
         if(nodeValues.size() > 1 && preferred > 1) {
             List<NodeValue<ByteArray, byte[]>> toReadRepair = Lists.newArrayList();
 
@@ -111,6 +113,15 @@ public abstract class AbstractReadRepair<K, V, PD extends PipelineData<K, V>> ex
                     logger.debug("Read repair failed: ", e);
                 }
             }
+
+            if(logger.isDebugEnabled()) {
+                String logStr = "Repaired (node, key, version): (";
+                for(NodeValue<ByteArray, byte[]> v: toReadRepair) {
+                    logStr += "(" + v.getNodeId() + ", " + v.getKey() + "," + v.getVersion() + ") ";
+                }
+                logStr += "in " + (System.nanoTime() - startNs) + " ns";
+                logger.debug(logStr);
+            }
         }
 
         pipeline.addEvent(completeEvent);
diff --git a/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java b/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
index c459057..a837341 100644
--- a/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformParallelPutRequests.java
@@ -129,6 +129,11 @@ public class PerformParallelPutRequests extends
                                                                                            requestTime);
                     responses.put(node.getId(), response);
 
+                    if(logger.isDebugEnabled())
+                        logger.debug("Finished secondary PUT for key " + key + " (keyRef: "
+                                     + System.identityHashCode(key) + "); took " + requestTime
+                                     + " ms on node " + node.getId() + "(" + node.getHost() + ")");
+
                     if(isHintedHandoffEnabled() && pipeline.isFinished()) {
                         if(response.getValue() instanceof UnreachableStoreException) {
                             Slop slop = new Slop(pipelineData.getStoreName(),
diff --git a/src/java/voldemort/store/routed/action/PerformParallelRequests.java b/src/java/voldemort/store/routed/action/PerformParallelRequests.java
index a5a0ef9..a0f73b4 100644
--- a/src/java/voldemort/store/routed/action/PerformParallelRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformParallelRequests.java
@@ -95,6 +95,8 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             final Node node = nodes.get(i);
             pipelineData.incrementNodeIndex();
 
+            final long startMs = System.currentTimeMillis();
+
             NonblockingStoreCallback callback = new NonblockingStoreCallback() {
 
                 public void requestComplete(Object result, long requestTime) {
@@ -107,6 +109,12 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
                                                                                            key,
                                                                                            result,
                                                                                            requestTime);
+                    if(logger.isDebugEnabled())
+                        logger.debug("Finished GET for key " + key + " (keyRef: "
+                                     + System.identityHashCode(key) + "); started at " + startMs
+                                     + " took " + requestTime + " ms on node " + node.getId() + "("
+                                     + node.getHost() + ")");
+
                     responses.put(node.getId(), response);
                     latch.countDown();
 
@@ -164,6 +172,10 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
         }
 
+        if(logger.isDebugEnabled())
+            logger.debug("GET for key " + key + " successes: " + pipelineData.getSuccesses()
+                         + " preferred: " + preferred + " required: " + required);
+
         if(pipelineData.getSuccesses() < required) {
             if(insufficientSuccessesEvent != null) {
                 pipeline.addEvent(insufficientSuccessesEvent);
@@ -184,7 +196,6 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
 
         } else {
-
             if(pipelineData.getZonesRequired() != null) {
 
                 int zonesSatisfied = pipelineData.getZoneResponses().size();
@@ -216,5 +227,4 @@ public class PerformParallelRequests<V, PD extends BasicPipelineData<V>> extends
             }
         }
     }
-
 }
diff --git a/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java b/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
index 2f5d07e..e36da11 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialGetAllRequests.java
@@ -79,6 +79,10 @@ public class PerformSerialGetAllRequests
             boolean zoneRequirement = false;
             MutableInt successCount = pipelineData.getSuccessCount(key);
 
+            logger.debug("GETALL for key " + key + " (keyRef: " + System.identityHashCode(key)
+                         + ") successes: " + successCount.intValue() + " preferred: " + preferred
+                         + " required: " + required);
+
             if(successCount.intValue() >= preferred) {
                 if(pipelineData.getZonesRequired() != null) {
 
@@ -132,6 +136,13 @@ public class PerformSerialGetAllRequests
                     pipelineData.getResponses().add(response);
                     failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
 
+                    if(logger.isDebugEnabled())
+                        logger.debug("GET for key " + key + " (keyRef: "
+                                     + System.identityHashCode(key) + ") successes: "
+                                     + successCount.intValue() + " preferred: " + preferred
+                                     + " required: " + required + " new GET success on node "
+                                     + node.getId());
+
                     HashSet<Integer> zoneResponses = null;
                     if(pipelineData.getKeyToZoneResponse().containsKey(key)) {
                         zoneResponses = pipelineData.getKeyToZoneResponse().get(key);
@@ -187,5 +198,4 @@ public class PerformSerialGetAllRequests
 
         pipeline.addEvent(completeEvent);
     }
-
 }
\ No newline at end of file
diff --git a/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java b/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
index 5d8debe..8be08e0 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialPutRequests.java
@@ -74,11 +74,15 @@ public class PerformSerialPutRequests extends
         int currentNode = 0;
         List<Node> nodes = pipelineData.getNodes();
 
+        long startMasterMs = System.currentTimeMillis();
+        long startMasterNs = System.nanoTime();
+
         if(logger.isDebugEnabled())
             logger.debug("Performing serial put requests to determine master");
 
+        Node node = null;
         for(; currentNode < nodes.size(); currentNode++) {
-            Node node = nodes.get(currentNode);
+            node = nodes.get(currentNode);
             pipelineData.incrementNodeIndex();
 
             VectorClock versionedClock = (VectorClock) versioned.getVersion();
@@ -108,6 +112,12 @@ public class PerformSerialPutRequests extends
             } catch(Exception e) {
                 long requestTime = (System.nanoTime() - start) / Time.NS_PER_MS;
 
+                if(logger.isDebugEnabled())
+                    logger.debug("Master PUT at node " + currentNode + "(" + node.getHost() + ")"
+                                 + " failed (" + e.getMessage() + ") in "
+                                 + (System.nanoTime() - start) + " ns" + " (keyRef: "
+                                 + System.identityHashCode(key) + ")");
+
                 if(handleResponseError(e, node, requestTime, pipeline, failureDetector))
                     return;
             }
@@ -161,6 +171,12 @@ public class PerformSerialPutRequests extends
                 }
             }
         } else {
+            if(logger.isDebugEnabled())
+                logger.debug("Finished master PUT for key " + key + " (keyRef: "
+                             + System.identityHashCode(key) + "); started at " + startMasterMs
+                             + " took " + (System.nanoTime() - startMasterNs) + " ns on node "
+                             + node.getId() + "(" + node.getHost() + ")");
+
             pipeline.addEvent(masterDeterminedEvent);
         }
     }
diff --git a/src/java/voldemort/store/routed/action/PerformSerialRequests.java b/src/java/voldemort/store/routed/action/PerformSerialRequests.java
index 70c8fa5..cd3526e 100644
--- a/src/java/voldemort/store/routed/action/PerformSerialRequests.java
+++ b/src/java/voldemort/store/routed/action/PerformSerialRequests.java
@@ -98,6 +98,12 @@ public class PerformSerialRequests<V, PD extends BasicPipelineData<V>> extends
                                                                              result,
                                                                              ((System.nanoTime() - start) / Time.NS_PER_MS));
 
+                if(logger.isDebugEnabled())
+                    logger.debug("GET for key " + key + " successes: "
+                                 + pipelineData.getSuccesses() + " preferred: " + preferred
+                                 + " required: " + required + " new GET success on node "
+                                 + node.getId());
+
                 pipelineData.incrementSuccesses();
                 pipelineData.getResponses().add(response);
                 failureDetector.recordSuccess(response.getNode(), response.getRequestTime());
diff --git a/src/java/voldemort/store/slop/HintedHandoff.java b/src/java/voldemort/store/slop/HintedHandoff.java
index a4a6621..2205fbc 100644
--- a/src/java/voldemort/store/slop/HintedHandoff.java
+++ b/src/java/voldemort/store/slop/HintedHandoff.java
@@ -27,10 +27,10 @@ import voldemort.serialization.Serializer;
 import voldemort.serialization.SlopSerializer;
 import voldemort.store.Store;
 import voldemort.store.UnreachableStoreException;
-import voldemort.store.slop.strategy.HintedHandoffStrategy;
 import voldemort.store.nonblockingstore.NonblockingStore;
 import voldemort.store.nonblockingstore.NonblockingStoreCallback;
 import voldemort.store.routed.Response;
+import voldemort.store.slop.strategy.HintedHandoffStrategy;
 import voldemort.utils.ByteArray;
 import voldemort.utils.Time;
 import voldemort.utils.Utils;
@@ -67,7 +67,8 @@ public class HintedHandoff {
      * Create a Hinted Handoff object
      * 
      * @param failureDetector The failure detector
-     * @param nonblockingSlopStores A map of node ids to nonb-locking slop stores
+     * @param nonblockingSlopStores A map of node ids to nonb-locking slop
+     *        stores
      * @param slopStores A map of node ids to blocking slop stores
      * @param handoffStrategy The {@link HintedHandoffStrategy} implementation
      * @param failedNodes A list of nodes in the original preflist for the
@@ -89,30 +90,35 @@ public class HintedHandoff {
     }
 
     /**
-     * Like {@link #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)},
-     * but doesn't block the pipeline. Intended for handling prolonged failures without
-     * incurring a performance cost.
-     *
-     * @see #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)
+     * Like
+     * {@link #sendHintSerial(voldemort.cluster.Node, voldemort.versioning.Version, Slop)}
+     * , but doesn't block the pipeline. Intended for handling prolonged
+     * failures without incurring a performance cost.
+     * 
+     * @see #sendHintSerial(voldemort.cluster.Node,
+     *      voldemort.versioning.Version, Slop)
      */
     public void sendHintParallel(final Node failedNode, final Version version, final Slop slop) {
         final ByteArray slopKey = slop.makeKey();
-        Versioned<byte[]> slopVersioned = new Versioned<byte[]>(slopSerializer.toBytes(slop), version);
+        Versioned<byte[]> slopVersioned = new Versioned<byte[]>(slopSerializer.toBytes(slop),
+                                                                version);
 
         for(final Node node: handoffStrategy.routeHint(failedNode)) {
             int nodeId = node.getId();
-            if(logger.isTraceEnabled())
-                logger.trace("Sending an async hint to " + nodeId);
+
+            logger.debug("Sending an async hint to " + nodeId);
 
             if(!failedNodes.contains(node) && failureDetector.isAvailable(node)) {
                 NonblockingStore nonblockingStore = nonblockingSlopStores.get(nodeId);
                 Utils.notNull(nonblockingStore);
                 final long startNs = System.nanoTime();
-                if(logger.isTraceEnabled())
-                    logger.trace("Attempt to write " + slop.getKey() + " for " + failedNode
+
+                if(logger.isDebugEnabled())
+                    logger.debug("Slop attempt to write " + slop.getKey() + " for " + failedNode
                                  + " to node " + node);
 
                 NonblockingStoreCallback callback = new NonblockingStoreCallback() {
+
                     public void requestComplete(Object result, long requestTime) {
                         Response<ByteArray, Object> response = new Response<ByteArray, Object>(node,
                                                                                                slopKey,
@@ -127,31 +133,39 @@ public class HintedHandoff {
                                     failedNodes.add(node);
                                 if(response.getValue() instanceof UnreachableStoreException) {
                                     UnreachableStoreException use = (UnreachableStoreException) response.getValue();
+
+                                    logger.debug("Write of key " + slop.getKey() + " for "
+                                                 + failedNode + " to node " + node
+                                                 + " failed due to unreachable: "
+                                                 + use.getMessage());
+
                                     failureDetector.recordException(node,
                                                                     (System.nanoTime() - startNs)
-                                                                    / Time.NS_PER_MS,
+                                                                            / Time.NS_PER_MS,
                                                                     use);
                                 }
                                 sendHintSerial(failedNode, version, slop);
                             }
                             return;
                         }
+
+                        if(logger.isDebugEnabled())
+                            logger.debug("Slop write of key " + slop.getKey() + " for "
+                                         + failedNode + " to node " + node + " succeded in "
+                                         + (System.nanoTime() - startNs) + " ns");
+
                         failureDetector.recordSuccess(node, (System.nanoTime() - startNs)
                                                             / Time.NS_PER_MS);
 
                     }
                 };
 
-                nonblockingStore.submitPutRequest(slopKey,
-                                                  slopVersioned,
-                                                  null,
-                                                  callback,
-                                                  timeoutMs);
+                nonblockingStore.submitPutRequest(slopKey, slopVersioned, null, callback, timeoutMs);
                 break;
             }
         }
     }
-    
+
     /**
      * Send a hint of a request originally meant for the failed node to another
      * node in the ring, as selected by the {@link HintedHandoffStrategy}
@@ -166,8 +180,7 @@ public class HintedHandoff {
         boolean persisted = false;
         for(Node node: handoffStrategy.routeHint(failedNode)) {
             int nodeId = node.getId();
-            if(logger.isTraceEnabled())
-                logger.trace("Trying to send hint to " + nodeId);
+            logger.trace("Trying to send hint to " + nodeId);
 
             if(!failedNodes.contains(node) && failureDetector.isAvailable(node)) {
                 Store<ByteArray, Slop, byte[]> slopStore = slopStores.get(nodeId);
@@ -175,10 +188,10 @@ public class HintedHandoff {
                 long startNs = System.nanoTime();
 
                 try {
-                    if(logger.isTraceEnabled())
-                        logger.trace("Attempt to handoff " + slop.getOperation() + " on "
-                                     + slop.getKey() + " for " + failedNode
-                                     + " to node " + node);
+                    if(logger.isDebugEnabled())
+                        logger.debug("Slop attempt to write " + slop.getKey() + " (keyRef: "
+                                     + System.identityHashCode(slop.getKey()) + ") for "
+                                     + failedNode + " to node " + node);
 
                     // No transform needs to applied to the slop
                     slopStore.put(slop.makeKey(), new Versioned<Slop>(slop, version), null);
@@ -197,6 +210,12 @@ public class HintedHandoff {
                 } catch(ObsoleteVersionException e) {
                     logger.debug(e, e);
                 }
+
+                if(logger.isDebugEnabled())
+                    logger.debug("Slop write of key " + slop.getKey() + " (keyRef: "
+                                 + System.identityHashCode(slop.getKey()) + " for " + failedNode
+                                 + " to node " + node + " succeded in "
+                                 + (System.nanoTime() - startNs) + " ns");
             }
         }
 
diff --git a/src/java/voldemort/store/socket/SocketStore.java b/src/java/voldemort/store/socket/SocketStore.java
index 0886341..6fd1a3c 100644
--- a/src/java/voldemort/store/socket/SocketStore.java
+++ b/src/java/voldemort/store/socket/SocketStore.java
@@ -25,6 +25,7 @@ import java.util.Map;
 
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
+import org.mortbay.log.Log;
 
 import voldemort.VoldemortException;
 import voldemort.client.protocol.RequestFormat;
@@ -100,6 +101,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                     requestRoutingType,
                                                                     key,
                                                                     version);
+        if(logger.isDebugEnabled())
+            logger.debug("DELETE keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         requestAsync(clientRequest, callback, timeoutMs, "delete");
     }
 
@@ -113,6 +117,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                               requestRoutingType,
                                                               key,
                                                               transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("GET keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         requestAsync(clientRequest, callback, timeoutMs, "get");
     }
 
@@ -126,6 +133,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                     requestRoutingType,
                                                                     keys,
                                                                     transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("GETALL keyRef: " + System.identityHashCode(keys) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         requestAsync(clientRequest, callback, timeoutMs, "get all");
     }
 
@@ -137,6 +147,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                               requestFormat,
                                                                               requestRoutingType,
                                                                               key);
+        if(logger.isDebugEnabled())
+            logger.debug("GETVERSIONS keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         requestAsync(clientRequest, callback, timeoutMs, "get versions");
     }
 
@@ -152,6 +165,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                               key,
                                                               value,
                                                               transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("PUT keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         requestAsync(clientRequest, callback, timeoutMs, "put");
     }
 
@@ -162,6 +178,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                     requestRoutingType,
                                                                     key,
                                                                     version);
+        if(logger.isDebugEnabled())
+            logger.debug("DELETE keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         return request(clientRequest, "delete");
     }
 
@@ -172,6 +191,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                               requestRoutingType,
                                                               key,
                                                               transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("GET keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         return request(clientRequest, "get");
     }
 
@@ -184,6 +206,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                     requestRoutingType,
                                                                     keys,
                                                                     transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("GETALL keyRef: " + System.identityHashCode(keys) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         return request(clientRequest, "getAll");
     }
 
@@ -193,6 +218,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                                               requestFormat,
                                                                               requestRoutingType,
                                                                               key);
+        if(logger.isDebugEnabled())
+            logger.debug("GETVERSIONS keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         return request(clientRequest, "getVersions");
     }
 
@@ -205,6 +233,9 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                                                               key,
                                                               versioned,
                                                               transforms);
+        if(logger.isDebugEnabled())
+            logger.debug("PUT keyRef: " + System.identityHashCode(key) + " requestRef: "
+                         + System.identityHashCode(clientRequest));
         request(clientRequest, "put");
     }
 
@@ -240,17 +271,35 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
     private <T> T request(ClientRequest<T> delegate, String operationName) {
         ClientRequestExecutor clientRequestExecutor = pool.checkout(destination);
+
+        long startTimeNs = System.nanoTime();
+        long startTimeMs = System.currentTimeMillis();
+
+        String debugMsgStr = "";
+
         BlockingClientRequest<T> blockingClientRequest = null;
         try {
             blockingClientRequest = new BlockingClientRequest<T>(delegate, timeoutMs);
             clientRequestExecutor.addClientRequest(blockingClientRequest, timeoutMs);
             blockingClientRequest.await();
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "success";
+
             return blockingClientRequest.getResult();
         } catch(InterruptedException e) {
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "unreachable: " + e.getMessage();
+
             throw new UnreachableStoreException("Failure in " + operationName + " on "
                                                 + destination + ": " + e.getMessage(), e);
         } catch(IOException e) {
             clientRequestExecutor.close();
+
+            if(logger.isDebugEnabled())
+                debugMsgStr += "failure: " + e.getMessage();
+
             throw new UnreachableStoreException("Failure in " + operationName + " on "
                                                 + destination + ": " + e.getMessage(), e);
         } finally {
@@ -258,6 +307,29 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                 // close the executor if we timed out
                 clientRequestExecutor.close();
             }
+
+            if(logger.isDebugEnabled()) {
+                Log.debug("Sync request end, type: "
+                          + operationName
+                          + " requestRef: "
+                          + System.identityHashCode(delegate)
+                          + " totalTimeNs: "
+                          + (startTimeNs - System.nanoTime())
+                          + " start time: "
+                          + startTimeMs
+                          + "end time: "
+                          + System.currentTimeMillis()
+                          + "client:"
+                          + clientRequestExecutor.getSocketChannel().socket().getLocalAddress()
+                          + ":"
+                          + clientRequestExecutor.getSocketChannel().socket().getLocalPort()
+                          + " server: "
+                          + clientRequestExecutor.getSocketChannel()
+                                                 .socket()
+                                                 .getRemoteSocketAddress() + " outcome: "
+                          + debugMsgStr);
+            }
+
             pool.checkin(destination, clientRequestExecutor);
         }
     }
@@ -285,6 +357,23 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
         try {
             clientRequestExecutor = pool.checkout(destination);
+
+            if(logger.isDebugEnabled()) {
+                logger.debug("Async request start; type: "
+                             + operationName
+                             + " requestRef: "
+                             + System.identityHashCode(delegate)
+                             + " time: "
+                             + System.currentTimeMillis()
+                             + " server: "
+                             + clientRequestExecutor.getSocketChannel()
+                                                    .socket()
+                                                    .getRemoteSocketAddress() + " local socket: "
+                             + clientRequestExecutor.getSocketChannel().socket().getLocalAddress()
+                             + ":"
+                             + clientRequestExecutor.getSocketChannel().socket().getLocalPort());
+            }
+
         } catch(Exception e) {
             // If we can't check out a socket from the pool, we'll usually get
             // either an IOException (subclass) or an UnreachableStoreException
@@ -335,6 +424,26 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
         private void invokeCallback(Object o, long requestTime) {
             if(callback != null) {
                 try {
+                    if(logger.isDebugEnabled()) {
+                        logger.debug("Async request end; requestRef: "
+                                     + System.identityHashCode(clientRequest)
+                                     + "time: "
+                                     + System.currentTimeMillis()
+                                     + " server: "
+                                     + clientRequestExecutor.getSocketChannel()
+                                                            .socket()
+                                                            .getRemoteSocketAddress()
+                                     + " local socket: "
+                                     + clientRequestExecutor.getSocketChannel()
+                                                            .socket()
+                                                            .getLocalAddress()
+                                     + ":"
+                                     + clientRequestExecutor.getSocketChannel()
+                                                            .socket()
+                                                            .getLocalPort() + " result: "
+                                     + o.toString());
+                    }
+
                     callback.requestComplete(o, requestTime);
                 } catch(Exception e) {
                     if(logger.isEnabledFor(Level.WARN))
