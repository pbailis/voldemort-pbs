diff --git a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
index b74b60a..4f12d06 100644
--- a/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
+++ b/src/java/voldemort/server/protocol/vold/VoldemortNativeRequestHandler.java
@@ -269,6 +269,8 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
     private void handleGet(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeNs = System.nanoTime();
+
         ByteArray key = readKey(inputStream);
 
         byte[] transforms = null;
@@ -286,12 +288,16 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
             return;
         }
         writeResults(outputStream, results);
+
+        debugLogReturnValue(key, results, startTimeNs, "GET");
     }
 
     private void handleGetAll(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
         // read keys
+        long startTimeNs = System.nanoTime();
+
         int numKeys = inputStream.readInt();
         List<ByteArray> keys = new ArrayList<ByteArray>(numKeys);
         for(int i = 0; i < numKeys; i++)
@@ -321,18 +327,51 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
 
         // write back the results
         outputStream.writeInt(results.size());
+
+        logger.debug("GETALL start");
+
         for(Map.Entry<ByteArray, List<Versioned<byte[]>>> entry: results.entrySet()) {
             // write the key
             outputStream.writeInt(entry.getKey().length());
             outputStream.write(entry.getKey().get());
             // write the values
             writeResults(outputStream, entry.getValue());
+
+            debugLogReturnValue(entry.getKey(), entry.getValue(), startTimeNs, "GETALL");
+        }
+
+        logger.debug("GETALL end");
+    }
+
+    private void debugLogReturnValue(ByteArray key,
+                                     List<Versioned<byte[]>> values,
+                                     long startTimeNs,
+                                     String getType) {
+        if(logger.isDebugEnabled()) {
+            long totalValueSize = 0;
+            String valueSizeStr = "[";
+            String valueHashStr = "[";
+            for(Versioned<byte[]> b: values) {
+                int len = b.getValue().length;
+                totalValueSize += len;
+                valueSizeStr += len + ",";
+                valueHashStr += b.hashCode() + ",";
+            }
+            valueSizeStr += "]";
+            valueHashStr += "]";
+
+            logger.debug(getType + " key: " + key + " " + (System.nanoTime() - startTimeNs)
+                         + " ns, keySize: " + key.length() + " numResults: " + values.size()
+                         + " totalResultSize: " + totalValueSize + " resultSizes: " + valueSizeStr
+                         + "resultHashes: " + valueHashStr + "time: " + System.currentTimeMillis());
         }
     }
 
     private void handlePut(DataInputStream inputStream,
                            DataOutputStream outputStream,
                            Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeNs = System.nanoTime();
+
         ByteArray key = readKey(inputStream);
         int valueSize = inputStream.readInt();
         byte[] bytes = new byte[valueSize];
@@ -352,11 +391,17 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        logger.debug("PUT key: " + key + " " + (System.nanoTime() - startTimeNs) + " ns, keySize: "
+                     + key.length() + "valueHash: " + value.hashCode() + " valueSize: " + valueSize
+                     + " clockSize: " + clock.sizeInBytes() + " time: "
+                     + System.currentTimeMillis());
     }
 
     private void handleDelete(DataInputStream inputStream,
                               DataOutputStream outputStream,
                               Store<ByteArray, byte[], byte[]> store) throws IOException {
+        long startTimeNs = System.nanoTime();
         ByteArray key = readKey(inputStream);
         int versionSize = inputStream.readShort();
         byte[] versionBytes = new byte[versionSize];
@@ -369,6 +414,9 @@ public class VoldemortNativeRequestHandler extends AbstractRequestHandler implem
         } catch(VoldemortException e) {
             writeException(outputStream, e);
         }
+
+        logger.debug("DELETE key: " + key + " " + (System.nanoTime() - startTimeNs)
+                     + " ns, keySize: " + key.length() + " clockSize: " + version.sizeInBytes());
     }
 
     private void writeException(DataOutputStream stream, VoldemortException e) throws IOException {
diff --git a/src/java/voldemort/server/socket/SocketServerSession.java b/src/java/voldemort/server/socket/SocketServerSession.java
index 978cc9e..604671e 100644
--- a/src/java/voldemort/server/socket/SocketServerSession.java
+++ b/src/java/voldemort/server/socket/SocketServerSession.java
@@ -74,6 +74,9 @@ public class SocketServerSession implements Runnable {
             while(!isInterrupted() && !socket.isClosed() && !isClosed) {
                 StreamRequestHandler srh = handler.handleRequest(inputStream, outputStream);
 
+                logger.debug("Handled request from " + socket.getRemoteSocketAddress() + " time: "
+                             + System.currentTimeMillis());
+
                 if(srh != null) {
                     if(logger.isTraceEnabled())
                         logger.trace("Request is streaming");
@@ -87,6 +90,10 @@ public class SocketServerSession implements Runnable {
 
                             srhs = srh.handleRequest(inputStream, outputStream);
 
+                            logger.debug("Handled streaming request from "
+                                         + socket.getRemoteSocketAddress() + " time: "
+                                         + System.currentTimeMillis());
+
                             if(logger.isTraceEnabled())
                                 logger.trace("Finished invocation of streaming request handler, result is "
                                              + srhs);
diff --git a/src/java/voldemort/store/bdb/BdbStorageEngine.java b/src/java/voldemort/store/bdb/BdbStorageEngine.java
index 61d809e..7d28e5f 100644
--- a/src/java/voldemort/store/bdb/BdbStorageEngine.java
+++ b/src/java/voldemort/store/bdb/BdbStorageEngine.java
@@ -275,15 +275,25 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
                                    Serializer<T> serializer) throws DatabaseException {
         StoreUtils.assertValidKey(key);
 
+        long startNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         DatabaseEntry valueEntry = new DatabaseEntry();
         List<T> results = Lists.newArrayList();
 
+        String valueStr = "";
+
         for(OperationStatus status = cursor.getSearchKey(keyEntry, valueEntry, lockMode); status == OperationStatus.SUCCESS; status = cursor.getNextDup(keyEntry,
                                                                                                                                                         valueEntry,
                                                                                                                                                         lockMode)) {
+            if(logger.isDebugEnabled())
+                valueStr += valueEntry.getData() + ",";
             results.add(serializer.toObject(valueEntry.getData()));
         }
+
+        logger.debug("Completed GET from key " + key + " values [" + valueStr + "] in "
+                     + (System.nanoTime() - startNs) + " ns at " + System.currentTimeMillis());
+
         return results;
     }
 
@@ -291,6 +301,8 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             throws PersistenceFailureException {
         StoreUtils.assertValidKey(key);
 
+        long startNs = System.nanoTime();
+
         DatabaseEntry keyEntry = new DatabaseEntry(key.get());
         boolean succeeded = false;
         Transaction transaction = null;
@@ -338,6 +350,9 @@ public class BdbStorageEngine implements StorageEngine<ByteArray, byte[], byte[]
             else
                 attemptAbort(transaction);
         }
+
+        logger.debug("Completed PUT to key " + key + " value " + value + " in "
+                     + (System.nanoTime() - startNs) + " ns at " + System.currentTimeMillis());
     }
 
     public boolean delete(ByteArray key, Version version) throws PersistenceFailureException {
diff --git a/src/java/voldemort/store/routed/ThreadPoolRoutedStore.java b/src/java/voldemort/store/routed/ThreadPoolRoutedStore.java
index 947b44f..bb9112b 100644
--- a/src/java/voldemort/store/routed/ThreadPoolRoutedStore.java
+++ b/src/java/voldemort/store/routed/ThreadPoolRoutedStore.java
@@ -444,6 +444,10 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                             Function<List<GetResult<R>>, Void> preReturnProcedure)
             throws VoldemortException {
         StoreUtils.assertValidKey(key);
+
+        long startMs = System.currentTimeMillis();
+        long startNs = System.nanoTime();
+
         final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));
 
         // quickly fail if there aren't enough nodes to meet the requirement
@@ -507,18 +511,32 @@ public class ThreadPoolRoutedStore extends RoutedStore {
         // reads to make up for these.
         while(successes < this.storeDef.getPreferredReads() && nodeIndex < nodes.size()) {
             Node node = nodes.get(nodeIndex);
-            long startNs = System.nanoTime();
             try {
+                logger.debug("GET for key; insufficient preferred for key " + key + " preferred: "
+                             + this.storeDef.getPreferredReads() + " got: " + successes
+                             + " attempting to GET from node " + nodeIndex);
+
                 retrieved.add(new GetResult<R>(node,
                                                key,
                                                fetcher.execute(innerStores.get(node.getId()),
                                                                key,
                                                                transforms), null));
                 ++successes;
+
+                logger.debug("GET for key; insufficient preferred for key " + key + " preferred: "
+                             + this.storeDef.getPreferredReads() + " got: " + successes
+                             + " GET from node " + nodeIndex + " succeeded");
+
                 recordSuccess(node, startNs);
             } catch(UnreachableStoreException e) {
                 failures.add(e);
                 recordException(node, startNs, e);
+
+                logger.debug("GET for key; insufficient preferred for key " + key + " preferred: "
+                             + this.storeDef.getPreferredReads() + " got: " + successes
+                             + " GET from node " + nodeIndex + " failed; unreachable "
+                             + e.getMessage());
+
             } catch(VoldemortApplicationException e) {
                 throw e;
             } catch(Exception e) {
@@ -534,6 +552,11 @@ public class ThreadPoolRoutedStore extends RoutedStore {
         if(preReturnProcedure != null)
             preReturnProcedure.apply(retrieved);
 
+        logger.debug("Finished GET for key " + key + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs) + " values: " + formatNodeValues(retrieved)
+                     + " preferred: " + this.storeDef.getPreferredReads() + " required: "
+                     + this.storeDef.getRequiredReads() + " got: " + retrieved.size());
+
         if(successes >= this.storeDef.getRequiredReads()) {
             List<R> result = Lists.newArrayListWithExpectedSize(retrieved.size());
             for(GetResult<R> getResult: retrieved)
@@ -582,14 +605,18 @@ public class ThreadPoolRoutedStore extends RoutedStore {
         this.executor.execute(new Runnable() {
 
             public void run() {
+                long startNs = System.nanoTime();
                 for(NodeValue<ByteArray, byte[]> v: toReadRepair) {
                     try {
-                        if(logger.isDebugEnabled())
-                            logger.debug("Doing read repair on node " + v.getNodeId()
-                                         + " for key '" + v.getKey() + "' with version "
-                                         + v.getVersion() + ".");
+                        long startNsLocal = System.nanoTime();
+
                         // no transforms since this is read repair
                         innerStores.get(v.getNodeId()).put(v.getKey(), v.getVersioned(), null);
+
+                        logger.debug("Read repair on node " + v.getNodeId() + " for key '"
+                                     + v.getKey() + "' with version " + v.getVersion() + " took "
+                                     + (System.nanoTime() - startNsLocal) + " ns");
+
                     } catch(VoldemortApplicationException e) {
                         if(logger.isDebugEnabled())
                             logger.debug("Read repair cancelled due to application level exception on node "
@@ -604,6 +631,16 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                         logger.debug("Read repair failed: ", e);
                     }
                 }
+
+                if(logger.isDebugEnabled()) {
+                    String logStr = "Repaired (node, key, version): (";
+                    for(NodeValue<ByteArray, byte[]> v: toReadRepair) {
+                        logStr += "(" + v.getNodeId() + ", " + v.getKey() + "," + v.getVersion()
+                                  + ") ";
+                    }
+                    logStr += "in " + (System.nanoTime() - startNs) + " ns";
+                    logger.debug(logStr);
+                }
             }
         });
     }
@@ -633,6 +670,7 @@ public class ThreadPoolRoutedStore extends RoutedStore {
 
     public void put(final ByteArray key, final Versioned<byte[]> versioned, final byte[] transforms)
             throws VoldemortException {
+        long startMs = System.currentTimeMillis();
         long startNs = System.nanoTime();
         StoreUtils.assertValidKey(key);
         final List<Node> nodes = availableNodes(routingStrategy.routeRequest(key.get()));
@@ -660,6 +698,7 @@ public class ThreadPoolRoutedStore extends RoutedStore {
         for(; currentNode < numNodes; currentNode++) {
             Node current = nodes.get(currentNode);
             long startNsLocal = System.nanoTime();
+            long startMasterMs = System.currentTimeMillis();
             try {
                 versionedCopy = incremented(versioned, current.getId());
                 innerStores.get(current.getId()).put(key, versionedCopy, transforms);
@@ -669,12 +708,22 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                 break;
             } catch(UnreachableStoreException e) {
                 recordException(current, startNsLocal, e);
+                logger.debug("Master PUT at node " + current.getId() + "(" + current.getHost()
+                             + ")" + " failed (unreachable) in "
+                             + (System.nanoTime() - startNsLocal) + " ns");
                 failures.add(e);
             } catch(VoldemortApplicationException e) {
                 throw e;
             } catch(Exception e) {
+                logger.debug("Master PUT at node " + current.getId() + "(" + current.getHost()
+                             + ")" + " failed (" + e.getMessage() + ") in "
+                             + (System.nanoTime() - startNsLocal) + " ns");
                 failures.add(e);
             }
+
+            logger.debug("Finished master PUT for key " + key + "; started at " + startMasterMs
+                         + " took " + (System.nanoTime() - startNsLocal) + " ns on node "
+                         + current.getId() + "(" + current.getHost() + ")");
         }
 
         if(successes.get() < 1)
@@ -699,6 +748,7 @@ public class ThreadPoolRoutedStore extends RoutedStore {
 
                 public void run() {
                     long startNsLocal = System.nanoTime();
+                    long startMs = System.currentTimeMillis();
                     try {
                         innerStores.get(node.getId()).put(key, finalVersionedCopy, transforms);
                         successes.incrementAndGet();
@@ -718,6 +768,10 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                                     + ")", e);
                         failures.add(e);
                     } finally {
+                        logger.debug("Finished secondary PUT for key " + key + "; started at "
+                                     + startMs + " took " + (System.nanoTime() - startNsLocal)
+                                     + " ns on node " + node.getId() + "(" + node.getHost() + ")");
+
                         // signal that the operation is complete
                         semaphore.release();
                     }
@@ -757,6 +811,10 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                                                                 + " are required.", failures);
         }
 
+        logger.debug("Finished all PUTs for key " + key + "; started at " + startMs + " took "
+                     + (System.nanoTime() - startNs) + " preferred: "
+                     + storeDef.getPreferredWrites() + " achieved: " + successes.get());
+
         // Okay looks like it worked, increment the version for the caller
         VectorClock versionedClock = (VectorClock) versioned.getVersion();
         versionedClock.incrementVersion(master.getId(), time.getMilliseconds());
@@ -835,6 +893,7 @@ public class ThreadPoolRoutedStore extends RoutedStore {
         public GetResult<R> call() throws Exception {
             List<R> fetched = Collections.emptyList();
             Throwable exception = null;
+            long startMs = System.currentTimeMillis();
             long startNs = System.nanoTime();
             try {
                 if(logger.isTraceEnabled())
@@ -851,6 +910,11 @@ public class ThreadPoolRoutedStore extends RoutedStore {
                 logger.warn("Error in GET on node " + node.getId() + "(" + node.getHost() + ")", e);
                 exception = e;
             }
+
+            logger.debug("Finished GET for key " + key + "; started at " + startMs + " took "
+                         + (System.nanoTime() - startNs) + " ns on node " + node.getId() + "("
+                         + node.getHost() + ")");
+
             return new GetResult<R>(node, key, fetched, exception);
         }
     }
diff --git a/src/java/voldemort/store/socket/SocketStore.java b/src/java/voldemort/store/socket/SocketStore.java
index 0886341..fc3a45c 100644
--- a/src/java/voldemort/store/socket/SocketStore.java
+++ b/src/java/voldemort/store/socket/SocketStore.java
@@ -25,6 +25,7 @@ import java.util.Map;
 
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
+import org.mortbay.log.Log;
 
 import voldemort.VoldemortException;
 import voldemort.client.protocol.RequestFormat;
@@ -240,6 +241,10 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
     private <T> T request(ClientRequest<T> delegate, String operationName) {
         ClientRequestExecutor clientRequestExecutor = pool.checkout(destination);
+
+        long startTimeNs = System.nanoTime();
+        long startTimeMs = System.currentTimeMillis();
+
         BlockingClientRequest<T> blockingClientRequest = null;
         try {
             blockingClientRequest = new BlockingClientRequest<T>(delegate, timeoutMs);
@@ -258,6 +263,15 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
                 // close the executor if we timed out
                 clientRequestExecutor.close();
             }
+
+            Log.debug("Sync request end, type: " + operationName + " totalTimeNs: "
+                      + (startTimeNs - System.nanoTime()) + " start time: " + startTimeMs
+                      + "end time: " + System.currentTimeMillis() + "client:"
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalAddress() + ":"
+                      + clientRequestExecutor.getSocketChannel().socket().getLocalPort()
+                      + " server: "
+                      + clientRequestExecutor.getSocketChannel().socket().getRemoteSocketAddress());
+
             pool.checkin(destination, clientRequestExecutor);
         }
     }
@@ -285,6 +299,11 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
 
         try {
             clientRequestExecutor = pool.checkout(destination);
+
+            Log.warn("Async request start, type: " + operationName + " time: " + System.nanoTime()
+                     + " server: "
+                     + clientRequestExecutor.getSocketChannel().socket().getRemoteSocketAddress());
+
         } catch(Exception e) {
             // If we can't check out a socket from the pool, we'll usually get
             // either an IOException (subclass) or an UnreachableStoreException
@@ -335,6 +354,13 @@ public class SocketStore implements Store<ByteArray, byte[], byte[]>, Nonblockin
         private void invokeCallback(Object o, long requestTime) {
             if(callback != null) {
                 try {
+                    Log.warn("Async request end, time: "
+                             + System.nanoTime()
+                             + " server: "
+                             + clientRequestExecutor.getSocketChannel()
+                                                    .socket()
+                                                    .getRemoteSocketAddress());
+
                     callback.requestComplete(o, requestTime);
                 } catch(Exception e) {
                     if(logger.isEnabledFor(Level.WARN))
